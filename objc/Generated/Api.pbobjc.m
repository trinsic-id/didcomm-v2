// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Api.pbobjc.h"
#import "Security.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(EncryptedMessage);
GPBObjCClassDeclaration(GPBStruct);
GPBObjCClassDeclaration(JsonWebKey);
GPBObjCClassDeclaration(SignedMessage);

#pragma mark - ApiRoot

@implementation ApiRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - ApiRoot_FileDescriptor

static GPBFileDescriptor *ApiRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"didcomm.messaging"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum Crv

GPBEnumDescriptor *Crv_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Ed25519\000X25519\000P256\000Bls12381G2\000Secp256K1"
        "\000";
    static const int32_t values[] = {
        Crv_Ed25519,
        Crv_X25519,
        Crv_P256,
        Crv_Bls12381G2,
        Crv_Secp256K1,
    };
    static const char *extraTextFormatInfo = "\003\000\007\000\003\010\202\000\004\'\"\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Crv)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Crv_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Crv_IsValidValue(int32_t value__) {
  switch (value__) {
    case Crv_Ed25519:
    case Crv_X25519:
    case Crv_P256:
    case Crv_Bls12381G2:
    case Crv_Secp256K1:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum KeyType

GPBEnumDescriptor *KeyType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Okp\000Ec\000";
    static const int32_t values[] = {
        KeyType_Okp,
        KeyType_Ec,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(KeyType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:KeyType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL KeyType_IsValidValue(int32_t value__) {
  switch (value__) {
    case KeyType_Okp:
    case KeyType_Ec:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GenerateKeyRequest

@implementation GenerateKeyRequest

@dynamic seed;
@dynamic keyType;

typedef struct GenerateKeyRequest__storage_ {
  uint32_t _has_storage_[1];
  Crv keyType;
  NSData *seed;
} GenerateKeyRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "seed",
        .dataTypeSpecific.clazz = Nil,
        .number = GenerateKeyRequest_FieldNumber_Seed,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GenerateKeyRequest__storage_, seed),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "keyType",
        .dataTypeSpecific.enumDescFunc = Crv_EnumDescriptor,
        .number = GenerateKeyRequest_FieldNumber_KeyType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GenerateKeyRequest__storage_, keyType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GenerateKeyRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GenerateKeyRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GenerateKeyRequest_KeyType_RawValue(GenerateKeyRequest *message) {
  GPBDescriptor *descriptor = [GenerateKeyRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GenerateKeyRequest_FieldNumber_KeyType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetGenerateKeyRequest_KeyType_RawValue(GenerateKeyRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [GenerateKeyRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GenerateKeyRequest_FieldNumber_KeyType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - GenerateKeyResponse

@implementation GenerateKeyResponse

@dynamic hasKey, key;

typedef struct GenerateKeyResponse__storage_ {
  uint32_t _has_storage_[1];
  JsonWebKey *key;
} GenerateKeyResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.clazz = GPBObjCClass(JsonWebKey),
        .number = GenerateKeyResponse_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GenerateKeyResponse__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GenerateKeyResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GenerateKeyResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ConvertKeyRequest

@implementation ConvertKeyRequest

@dynamic hasKey, key;
@dynamic targetType;

typedef struct ConvertKeyRequest__storage_ {
  uint32_t _has_storage_[1];
  Crv targetType;
  JsonWebKey *key;
} ConvertKeyRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.clazz = GPBObjCClass(JsonWebKey),
        .number = ConvertKeyRequest_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ConvertKeyRequest__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "targetType",
        .dataTypeSpecific.enumDescFunc = Crv_EnumDescriptor,
        .number = ConvertKeyRequest_FieldNumber_TargetType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ConvertKeyRequest__storage_, targetType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ConvertKeyRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ConvertKeyRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ConvertKeyRequest_TargetType_RawValue(ConvertKeyRequest *message) {
  GPBDescriptor *descriptor = [ConvertKeyRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ConvertKeyRequest_FieldNumber_TargetType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetConvertKeyRequest_TargetType_RawValue(ConvertKeyRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [ConvertKeyRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ConvertKeyRequest_FieldNumber_TargetType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - ConvertKeyResponse

@implementation ConvertKeyResponse

@dynamic hasKey, key;

typedef struct ConvertKeyResponse__storage_ {
  uint32_t _has_storage_[1];
  JsonWebKey *key;
} ConvertKeyResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.clazz = GPBObjCClass(JsonWebKey),
        .number = ConvertKeyResponse_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ConvertKeyResponse__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ConvertKeyResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ConvertKeyResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SignRequest

@implementation SignRequest

@dynamic payload;
@dynamic hasKey, key;
@dynamic hasAppendTo, appendTo;

typedef struct SignRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *payload;
  JsonWebKey *key;
  SignedMessage *appendTo;
} SignRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "payload",
        .dataTypeSpecific.clazz = Nil,
        .number = SignRequest_FieldNumber_Payload,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SignRequest__storage_, payload),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "key",
        .dataTypeSpecific.clazz = GPBObjCClass(JsonWebKey),
        .number = SignRequest_FieldNumber_Key,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SignRequest__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "appendTo",
        .dataTypeSpecific.clazz = GPBObjCClass(SignedMessage),
        .number = SignRequest_FieldNumber_AppendTo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SignRequest__storage_, appendTo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SignRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SignRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SignResponse

@implementation SignResponse

@dynamic hasMessage, message;

typedef struct SignResponse__storage_ {
  uint32_t _has_storage_[1];
  SignedMessage *message;
} SignResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "message",
        .dataTypeSpecific.clazz = GPBObjCClass(SignedMessage),
        .number = SignResponse_FieldNumber_Message,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SignResponse__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SignResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SignResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VerifyRequest

@implementation VerifyRequest

@dynamic hasMessage, message;
@dynamic hasKey, key;

typedef struct VerifyRequest__storage_ {
  uint32_t _has_storage_[1];
  SignedMessage *message;
  JsonWebKey *key;
} VerifyRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "message",
        .dataTypeSpecific.clazz = GPBObjCClass(SignedMessage),
        .number = VerifyRequest_FieldNumber_Message,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VerifyRequest__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "key",
        .dataTypeSpecific.clazz = GPBObjCClass(JsonWebKey),
        .number = VerifyRequest_FieldNumber_Key,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VerifyRequest__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VerifyRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VerifyRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VerifyResponse

@implementation VerifyResponse

@dynamic isValid;

typedef struct VerifyResponse__storage_ {
  uint32_t _has_storage_[1];
} VerifyResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isValid",
        .dataTypeSpecific.clazz = Nil,
        .number = VerifyResponse_FieldNumber_IsValid,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VerifyResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VerifyResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PackRequest

@implementation PackRequest

@dynamic hasSenderKey, senderKey;
@dynamic hasReceiverKey, receiverKey;
@dynamic associatedData;
@dynamic plaintext;
@dynamic mode;
@dynamic algorithm;

typedef struct PackRequest__storage_ {
  uint32_t _has_storage_[1];
  EncryptionMode mode;
  EncryptionAlgorithm algorithm;
  JsonWebKey *senderKey;
  JsonWebKey *receiverKey;
  NSData *associatedData;
  NSData *plaintext;
} PackRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "senderKey",
        .dataTypeSpecific.clazz = GPBObjCClass(JsonWebKey),
        .number = PackRequest_FieldNumber_SenderKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PackRequest__storage_, senderKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "receiverKey",
        .dataTypeSpecific.clazz = GPBObjCClass(JsonWebKey),
        .number = PackRequest_FieldNumber_ReceiverKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PackRequest__storage_, receiverKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "associatedData",
        .dataTypeSpecific.clazz = Nil,
        .number = PackRequest_FieldNumber_AssociatedData,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PackRequest__storage_, associatedData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "plaintext",
        .dataTypeSpecific.clazz = Nil,
        .number = PackRequest_FieldNumber_Plaintext,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PackRequest__storage_, plaintext),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "mode",
        .dataTypeSpecific.enumDescFunc = EncryptionMode_EnumDescriptor,
        .number = PackRequest_FieldNumber_Mode,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PackRequest__storage_, mode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "algorithm",
        .dataTypeSpecific.enumDescFunc = EncryptionAlgorithm_EnumDescriptor,
        .number = PackRequest_FieldNumber_Algorithm,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PackRequest__storage_, algorithm),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PackRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PackRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PackRequest_Mode_RawValue(PackRequest *message) {
  GPBDescriptor *descriptor = [PackRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PackRequest_FieldNumber_Mode];
  return GPBGetMessageRawEnumField(message, field);
}

void SetPackRequest_Mode_RawValue(PackRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [PackRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PackRequest_FieldNumber_Mode];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t PackRequest_Algorithm_RawValue(PackRequest *message) {
  GPBDescriptor *descriptor = [PackRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PackRequest_FieldNumber_Algorithm];
  return GPBGetMessageRawEnumField(message, field);
}

void SetPackRequest_Algorithm_RawValue(PackRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [PackRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PackRequest_FieldNumber_Algorithm];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - PackResponse

@implementation PackResponse

@dynamic hasMessage, message;

typedef struct PackResponse__storage_ {
  uint32_t _has_storage_[1];
  EncryptedMessage *message;
} PackResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "message",
        .dataTypeSpecific.clazz = GPBObjCClass(EncryptedMessage),
        .number = PackResponse_FieldNumber_Message,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PackResponse__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PackResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PackResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnpackRequest

@implementation UnpackRequest

@dynamic hasSenderKey, senderKey;
@dynamic hasReceiverKey, receiverKey;
@dynamic hasMessage, message;

typedef struct UnpackRequest__storage_ {
  uint32_t _has_storage_[1];
  JsonWebKey *senderKey;
  JsonWebKey *receiverKey;
  EncryptedMessage *message;
} UnpackRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "senderKey",
        .dataTypeSpecific.clazz = GPBObjCClass(JsonWebKey),
        .number = UnpackRequest_FieldNumber_SenderKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UnpackRequest__storage_, senderKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "receiverKey",
        .dataTypeSpecific.clazz = GPBObjCClass(JsonWebKey),
        .number = UnpackRequest_FieldNumber_ReceiverKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UnpackRequest__storage_, receiverKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = GPBObjCClass(EncryptedMessage),
        .number = UnpackRequest_FieldNumber_Message,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UnpackRequest__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnpackRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UnpackRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnpackResponse

@implementation UnpackResponse

@dynamic plaintext;

typedef struct UnpackResponse__storage_ {
  uint32_t _has_storage_[1];
  NSData *plaintext;
} UnpackResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "plaintext",
        .dataTypeSpecific.clazz = Nil,
        .number = UnpackResponse_FieldNumber_Plaintext,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UnpackResponse__storage_, plaintext),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnpackResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UnpackResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetDidDocumentRequest

@implementation GetDidDocumentRequest

@dynamic hasKey, key;

typedef struct GetDidDocumentRequest__storage_ {
  uint32_t _has_storage_[1];
  JsonWebKey *key;
} GetDidDocumentRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.clazz = GPBObjCClass(JsonWebKey),
        .number = GetDidDocumentRequest_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetDidDocumentRequest__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDidDocumentRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDidDocumentRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetDidDocumentResponse

@implementation GetDidDocumentResponse

@dynamic hasDidDocument, didDocument;

typedef struct GetDidDocumentResponse__storage_ {
  uint32_t _has_storage_[1];
  GPBStruct *didDocument;
} GetDidDocumentResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "didDocument",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStruct),
        .number = GetDidDocumentResponse_FieldNumber_DidDocument,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetDidDocumentResponse__storage_, didDocument),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDidDocumentResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDidDocumentResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - JsonWebKey

@implementation JsonWebKey

@dynamic keyId;
@dynamic x;
@dynamic y;
@dynamic d;
@dynamic crv;
@dynamic kty;

typedef struct JsonWebKey__storage_ {
  uint32_t _has_storage_[1];
  Crv crv;
  KeyType kty;
  NSString *keyId;
  NSString *x;
  NSString *y;
  NSString *d;
} JsonWebKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "keyId",
        .dataTypeSpecific.clazz = Nil,
        .number = JsonWebKey_FieldNumber_KeyId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(JsonWebKey__storage_, keyId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "x",
        .dataTypeSpecific.clazz = Nil,
        .number = JsonWebKey_FieldNumber_X,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(JsonWebKey__storage_, x),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "y",
        .dataTypeSpecific.clazz = Nil,
        .number = JsonWebKey_FieldNumber_Y,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(JsonWebKey__storage_, y),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "d",
        .dataTypeSpecific.clazz = Nil,
        .number = JsonWebKey_FieldNumber_D,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(JsonWebKey__storage_, d),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "crv",
        .dataTypeSpecific.enumDescFunc = Crv_EnumDescriptor,
        .number = JsonWebKey_FieldNumber_Crv,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(JsonWebKey__storage_, crv),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "kty",
        .dataTypeSpecific.enumDescFunc = KeyType_EnumDescriptor,
        .number = JsonWebKey_FieldNumber_Kty,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(JsonWebKey__storage_, kty),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[JsonWebKey class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(JsonWebKey__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t JsonWebKey_Crv_RawValue(JsonWebKey *message) {
  GPBDescriptor *descriptor = [JsonWebKey descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:JsonWebKey_FieldNumber_Crv];
  return GPBGetMessageRawEnumField(message, field);
}

void SetJsonWebKey_Crv_RawValue(JsonWebKey *message, int32_t value) {
  GPBDescriptor *descriptor = [JsonWebKey descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:JsonWebKey_FieldNumber_Crv];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t JsonWebKey_Kty_RawValue(JsonWebKey *message) {
  GPBDescriptor *descriptor = [JsonWebKey descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:JsonWebKey_FieldNumber_Kty];
  return GPBGetMessageRawEnumField(message, field);
}

void SetJsonWebKey_Kty_RawValue(JsonWebKey *message, int32_t value) {
  GPBDescriptor *descriptor = [JsonWebKey descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:JsonWebKey_FieldNumber_Kty];
  GPBSetMessageRawEnumField(message, field, value);
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
